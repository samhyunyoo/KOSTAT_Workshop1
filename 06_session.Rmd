---
title: "Session 6 notes"
author: "Tim Riffe"
date: "2022-08-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## package installation

```{r, eval = FALSE}
install.packages("janitor")
install.packages("lubridate")
install.packages("ggridges")
install.packages("vroom")
install.packages("countrycode")
install.packages("remotes")
# this doesn't work for everyone? If that's
# you, then maybe update your R installation?
# if you have 4.2, then I'm not sure why it 
# would fail. Solution below assumes manual download 
# of wpp2022 data needed.
remotes::install_github("PPgp/wpp2022")
```

```{r, message = FALSE}
library(tidyverse)
library(lubridate)
library(ggridges)
library(vroom)
library(countrycode)
# handout uses the R package commented out for data
#library(wpp2022)
library(janitor)
```

## Get metadata
Read in the metadata on column positions and transform it into a column metadata format recognized by `read_fwf()`.
```{r}
metadata <- read_csv("https://raw.githubusercontent.com/timriffe/KOSTAT_Workshop1/master/Data/Korea_births_fwf_metadata.csv", show_col_types = FALSE)

specs <- fwf_widths(widths = metadata$width,
                    col_names = metadata$colname)
specs
```

## unzip the file

`exdir` is where we should put the unzipped contents
```{r}
unzip("Data/Korea_births_fwf.zip",
      exdir = "Data")
```

## read in all the data

```{r}
kb_files <-
  file.path("Data",
            "Korea_births_fwf",
            dir("Data/Korea_births_fwf"))

KB <- vroom_fwf(kb_files,
                col_positions = specs,
                col_types = "iiiiiiidddd")

# used this to count out the column types:
KB %>% colnames()
# to check the object size in memory 
KB %>% object.size() %>% print(units = "Mb")
```

## clean the names
```{r}
KB <- 
  KB %>% 
  clean_names() %>% 
  select(-year) %>% 
  select(year = year_of_birth,
         month = month_of_birth,
         fa_age = father_detailed_age,
         mo_age = mother_detailed_age,
         sex,
         p_weeks = no_of_weeks_of_pregnancy,
         kg = birth_weight)
```

## create a helper column for dates

We create this date column mostly for the sake of plotting
```{r}
ymd("2000 1 1")
paste("2000" , 1, "01") %>% ymd()

KB <-
  KB %>% 
  mutate(date = paste(year, month, 1) %>% ymd())
KB
```

## What is the trend and seasonality of births

The tabulation is straightforward in that `n()` counts rows in a subset. That's all we need to do for individual registry data. Note for plotting we take advantage of the ability to give different data pieces to two `geom_point()` calls to get the Dec-Jan points. By the way, no one offered me an explanation of why there are so many more January births than December births!
```{r}
KBmonths <-
  KB %>% 
  group_by(date) %>% 
  summarize(births = n()) 

KBmonths %>% 
  ggplot(mapping = aes(x = date, y = births)) +
  geom_line() +
  geom_point(data = KBmonths %>% filter(month(date) == 1),
             mapping = aes(x = date, y = births),
             color = "red") +
  geom_point(data = KBmonths %>% filter(month(date) == 12),
             mapping = aes(x = date, y = births),
             color = "blue")
```

## Exercise 1 (8 minutes)

Make a time series graph of average and median birth weight.
Instead of `n()`, use `mean()` and `median()` inside `summarize()`, then 
`pivot_longer()` to stack them for mapping...
*map `color` or `linetype` to the centrality measure.

Tell me if birth weight is seasonal and shout out a hypothesis as to why or why not.

```{r}
KB %>% 
  group_by(date) %>% 
  summarize(kg_median = median(kg),
            kg_mean = mean(kg)) %>% 
  pivot_longer(c(kg_median, kg_mean),
               names_to = "variant",
               values_to = "kg") %>% 
  ggplot(mapping = aes(x = date,
                       y = kg,
                       color = variant)) +
  geom_line() +
  labs(title = "Yes, birth weight is seasonal, but why?")
```

Here's a general way to make a density
```{r, eval = FALSE}
KB %>% 
  ggplot(aes(x = kg)) +
  geom_density()
```

Or a discretized version, accounting for the fact that digit precision varies in this data:

```{r}
KB %>% 
  mutate(kg = round(kg,1)) %>% 
  group_by(kg) %>% 
  summarize(births = n()) %>% 
  ggplot(mapping = aes(x=kg,y=births)) +
  geom_col()
```


Question: how much does this distribution vary by mother or father age? Target graphical form: `ridgeplot()`

The mapping: `x` is as usual. `y` refers to the baseline levels, and it needs to be `character` or `factor` apparently. `height` is the curve of each ridgeline.
```{r}
KB_kg_ridge_data <- 
  KB %>% 
  # throw out unknowns and mystery 0s
  filter(mo_age != 999,
         kg > 0) %>% 
  # aggregation bins
  mutate(mo_age = mo_age - mo_age %% 5,
         kg = round(kg, 1)) %>% 
  group_by(mo_age, kg) %>% 
  summarize(births = n(),
            .groups = "drop") %>% 
  group_by(mo_age) %>% 
  # densities so we can compare shape
  mutate(dens = births / sum(births))
  
KB_kg_ridge_data %>% 
  filter(mo_age < 60) %>% 
  ggplot(aes(x = kg, 
             y = factor(mo_age),
             height = dens)) +
  geom_ridgeline(scale = 15, alpha = .5)
```
Tim's interpretation, I see fatter left tails for ages <20 and >35. More variance in higher ages. That's what I see. It's measurable of course, shall we check? Here's a solution for variance:

```{r}
KB %>% 
  # throw out unknowns and mystery 0s
  filter(mo_age != 999,
         kg > 0) %>%
  mutate(mo_age = mo_age - mo_age %% 5) %>% 
  group_by(mo_age) %>% 
  summarize(vkg = var(kg)) %>% 
  ggplot(mapping = aes(x= mo_age, y = vkg))+
  geom_line() +
  labs(title = "So, there's a U-shape to variance f birth weight by mother age")
```

### a direct look at the birthweight distribution over months

```{r}
KB %>% 
  mutate(sex = if_else(sex == 1, "boys", "girls"),
         kg = round(kg,1)) %>% 
  group_by(month, sex, kg) %>% 
  summarize(births = n(),
            .groups = "drop") %>% 
  ggplot(mapping = aes(x = kg, 
                       y = factor(month, levels = 1:12), 
                       height = births, 
                       fill = sex)) +
  geom_ridgeline(scale = .00005, alpha = .4) +
  scale_fill_manual(values = c(boys = "#5899d1",
                               girls = "#db6bab")) +
  xlim(2,4.1) +
  coord_flip()
```
```{r, fig.height = 10, fig.width = 12}

KB %>%
  filter(between(p_weeks,28,37)) %>% 
  group_by(date) %>% 
  summarize(p_mean = mean(p_weeks),
            births = n(),
            .groups = "drop") %>% 
  ggplot(mapping = aes(x = date, 
                       y = births)) +
  geom_line()
```


## Question: 
Is the above age pattern of the distribution of birth weight different or identical for boys and girls?

This is just plugging in `sex` strategically to the earlier pipeline. We group on `sex` for tabulation, for instance, and then just include it for the `fill` arg.
```{r}
KB_kg_ridge_data_sex <- 
  # remove unk ages of mothers
  KB %>% 
  filter(mo_age != 999,
         # remove mystery 0 weight at birth
         kg > 0) %>% 
  # create intervals to aggregate within,
  # recode, etc
  mutate(mo_age = mo_age - mo_age %% 5,
         kg = round(kg, 1),
         sex = if_else(sex == 1, "boy","girl")) %>% 
  # perform tabulation of cases
  group_by(mo_age, kg, sex) %>% 
  summarize(births = n(),
            .groups = "drop") %>% 
  # calculate densities
  group_by(mo_age, sex) %>% 
  mutate(dens = births / sum(births)) %>% 
  ungroup()
  
KB_kg_ridge_data_sex %>% 
  filter(mo_age < 60) %>% 
  ggplot(aes(x = kg, 
             y = factor(mo_age), # the baseline of the ridgeplot
             height = dens,
             fill = sex)) +
  geom_ridgeline(scale = 15, alpha = .5) +
  labs(title = "boy births have greater birth weight on average, it seems.")
```

## Process exposure data

Now it's time to process the exposure data. I ran into an unexpected roadblock here, since I has assumed the `wpp2022` package would work for everyone. You can see how to process that data in the handout. Instead we downloaded the main Excel files. Note we originally tried letting `read_excel()` guess the column types, but (i) it did a bad job, and (ii) every time it made a mistake it printed a warning, and (iii) since there were thousands of warnings, my `R` session crashed (how embarrassing). 

I then restarted my session and *tried* telling `read_excel()` what the data types of each column were, but I made the mistake of using the same column class shorthand trick from the `readr` package. Instead of e.g. `ttnn` we ought to specify something of the form `c("text","text","numeric","numeric")`. HT Rustam for coming to this solution and carrying the session to the end!

Here's the completed exposure processing code. The output is now part of the repository, so you don't need to run this unless you want to explore how it's working.
```{r, eval = FALSE}
library(readxl)
col_types <- c(rep("text",10),rep("numeric",102))

library(countrycode)

# how to know we need location code 410 for Korea:
countrycode("South Korea",
            origin = "country.name.en",
            destination = "un")

Ef <- 
  suppressWarnings(read_excel("Data/WPP2022_POP_F01_3_POPULATION_SINGLE_AGE_FEMALE.xlsx", 
                skip = 16, 
                col_types = col_types)) %>% 
  filter(`Location code` == 410) %>% 
  pivot_longer(`0`:`100+`,
               names_to = "age",
               values_to = "expos") %>% 
  select(year = Year,
         age, 
         expos) %>% 
  mutate(sex = "f")

Em <- suppressWarnings(
  read_excel("Data/WPP2022_POP_F01_2_POPULATION_SINGLE_AGE_MALE.xlsx", 
                skip = 16, 
                col_types = col_types)) %>% 
  filter(`Location code` == 410) %>% 
  pivot_longer(`0`:`100+`,
               names_to = "age",
               values_to = "expos") %>% 
  select(year = Year,
         age, 
         expos) %>% 
  mutate(sex = "m")

E <-
  bind_rows(Ef,Em)

write_csv(E, "Data/Korea_exposures.csv")
```


## Big Exercise

We ended with an ambitious exercise to work through at the start of the next session. I believe it will consist in a somewhat novel question

1. Look in the git repo for a file called `Korea_exposures.csv` in the `Data` folder. Read it in directly from the web using `read_csv()`.
2. Tabulate the births data by single ages. Note that some ages have decimals, you can round them down using floor() before tabulating.
3. Note that 999 is the missing code for ages.
4. Redistribute missing ages in each year for men and women.
5. Join the join the mothers’ file and fathers’ file (births) into a single file that can be joined with the exposures. To do this right before joining you’ll rename `mo_age` to `age` and `fa_age` to `age`, and you'll need to create a `sex` variable, with value `"f"` in the women file and `"m"` for the men file. This is for the sake of an easy join with the exposure data. You may with to complete the age range with 0s to pad any missing ages, using the `complete()` function as in the handout.
6. Then calculate male and female fertility rates
7. Calculate `TFR` and `MAB` for men and women in each year
8. Calculate `TFRadj` (see Friday solution) for men and women in each year.
9. Tell me how similar / parallel / convergent / divergent the male and female trends in `TFR` and `TFRadj` are.

