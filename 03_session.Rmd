---
title: "Session 3 notes"
author: "Tim Riffe"
date: "2023-07-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Review

```{r, message = FALSE}
library(tidyverse)
source("https://raw.githubusercontent.com/timriffe/KOSTAT_Workshop1/master/lifetable_utils.R")
```


```{r}
hmd <- read_csv("https://github.com/timriffe/KOSTAT_Workshop1/raw/master/Data/hmd.csv.gz",
                show_col_types = FALSE)
```

## Question: why `pull()`?

`pull()` was used to extract a column from a dataset. You could also use `[["mx]]`, `$mx`. You'll see these other two idioms in older R code. There are actually more ways than this, and I don't recommend them. The reason why we wanted a vector was for testing functions we were writing, as a piece of toy data.
```{r}
hmd |> str()

hmd |> 
  filter(sex == "f",
         country == "Australia",
         year == 2020) |> 
  pull(mx)
chunk <- 
  hmd |> 
  filter(sex == "f",
         country == "Australia",
         year == 2020)
chunk$mx
mx <- chunk[["mx"]]
```

## Recycling functions and demonstrating frailty composition

First, let's pretend there are two subpopulations, one with high and one with low mortality.
Let's calculate lifetables for them, and see how their relative weights change over age. In the end, the low-mortality subpopulation dominates.
```{r}

mx1 <- mx
mx2 <- mx1 * 4

frailty <- 
  tibble(age = 0:110, low = mx1, high = mx2) |> 
  pivot_longer(c(low, high), names_to = "frailty", values_to = "mx") |> 
  # each subset has 111 rows
  group_by(frailty) |> 
  mutate(
     n = 1,
     # HT Ruchira for pointing out that ax was missing here
     ax = c(.1,rep(.5,110)),
     qx = calc_qx(mx,ax,n),
     lx = calc_lx(qx)) |> 
  ungroup() |> 
  # each subset has 2 rows
  group_by(age) |> 
  mutate(w = lx / sum(lx))
```

Now we want to be able to plot the population average on top of it. For this, we take the earlier result and aggregate it using the `group_by() |> summarise()` idiom.
```{r}
avg <-
  frailty |> 
  group_by(age) |> 
  summarize(mx = sum(mx * w))
```

Now we can compose the plot with two layers. In the first, we map color to the frailty subsets. We do that mapping directly inside the `geom_line()` for that layer, because the color mapping should only apply to that layer. Then we can add another line on top for the population average
```{r}
frailty |> 
  ggplot(aes(x = age, y = mx)) +
  geom_line(mapping = aes(color = frailty)) +
  geom_line(data = avg, color = "black", linewidth = 2) +
  scale_y_log10() 
```

This demonstrates the power of risk strata to (i) change the composition of the population over age, and (ii) affect the aggregate outcome. It begs the question: how much of a trend is due to the actual conditions of the phenomenon of interest, and how much is due to compositional change?

Note: at first I forgot to include `ax` in the calculations. Note, `calc_qx()` requires `ax`, and I assigned it. The code didn't break because coincidentally I had a vector called `ax` in active memory. Since `mutate()` didn't find `ax` among the columns in the data, it used the `ax` it found in the environment. However, if we were to re-run this code in a fresh session (or simply build the document) we would provoke an error. Thanks Ruchira for bringing this to my attention.

## Explore this HMD dataset

How many distinct subsets are there in the data? A subset is defined by unique combinations of country, sex, and year. `distinct()` can be used to remove redundant rows.
```{r}
hmd |> 
  select(country, sex, year) |> 
  distinct() |> 
  nrow()
```

## Visualize all of the mortality rates

Exercise: plot all the mortality patterns in a single plot.
Note, to tell ggplot how to split / group the lines, use the `groups` mapping. Since we have 3 different key variables (`country`,`sex`, and `year`), you'll need to list all three for `groups`. To do so jointly, try `interaction(country, sex, year)`. Try setting `alpha` to something like .01 or .02. Don't forget to log the y axis (don't log the data itself).

```{r}

a <- 0:100
a - a %% 5

p <-
hmd |> 
  mutate(century = year - year %% 100) |> 
  ggplot(mapping = aes(x = age, 
                       y = mx, 
                       group = interaction(country, year))) +
  geom_line(alpha = .01) +
  scale_y_log10() +
  facet_grid(rows = vars(century),cols = vars(sex)) +
  theme_minimal()

ggsave("hmdmx.pdf", plot = p, height = 30, width = 8, units = "cm")
```

Note: we use modulo `%%` (remainder) to create century groupings for the panel plot. The panel is specified using `facet_grid()` because we ended up wanting side-by-side plots for sex and ordered vertically by century. You might think of using this panel technique for other sorts of contrasts. If there are few lines, then there's no need to separate panels. In this case, I was just trying to parse the data down to reduce overlap between lines.


Exercise: plot a single country-year on top of this background pattern.
```{r}
hmd <-
  hmd |> 
  filter(year >= 1990) |> 
  mutate(mx2 = if_else(mx == 0, NA_real_, mx)) 

highlight <-  
  hmd |> 
  filter(country == "Bulgaria", 
         year == 2021)
hmd |> 
  ggplot(aes(x = age, y = mx2, group = interaction(year,country))) +
  geom_line(alpha = .02, color = gray(.5)) +
  scale_y_log10() +
  facet_wrap(~sex) +
  theme_minimal() +
  geom_line(data = highlight, 
            color = "red")

hmd |> pull(country) |> unique()
```

## Sanderson Scherbov prospective age threshold

```{r}
ex <-
  hmd |> 
  filter(country == "France",
         year == 2003,
         sex == "m") |> 
  mutate(n = 1,
         qx = calc_qx(mx,ax,n),
         lx = calc_lx(qx),
         dx = calc_dx(lx,qx),
         Lx = calc_Lx(lx,dx,ax,n),
         Tx = calc_Tx(Lx),
         ex = calc_ex(Tx,lx)) |> 
  pull(ex)
```

Now we need to do an interpolation of some kind. The goal will be to predict the age where `ex` hits exactly 15.

Here's how we can get a cheap linear interpolation using base `R`. `approx()` fits and spline and fits a requested prediction, giving back both `x` and `y` coordinates in a list structure. But I find `approxfun()` more convenient because the output is easier to handle mostly. They give identical results.
```{r}
approx(x= 0:110, y = ex, xout = 15)$y
approxfun(x=0:110, y = ex)(15)
```

 We could also do a spline interpolation
 
```{r}
splinefun(x = 0:110, y = ex)(15)
```
 

# Exercise: make a function that returns a threshold age

Note: we want the value of 15 to be a parameter. You can call the argument `threshold` if you want. If by default you want it to be 15, then set `threshold = 15` when defining the function. It doesn't matter which method you use, linear or spline.

```{r}
ex_threshold <- function(age, ex, threshold = 15){
  age_star <- splinefun(x = age, y = ex)(threshold)
  return(age_star)
}
ex_threshold(age, ex, threshold = 20)

plot(0:110, ex, type = 'l')
abline(a = 15, b = 0)
```

Exercise (~15 min):

Calculate all lifetables using the HMD data (remember to group by country, sex, year). You can use the same `mutate()` call that we did earlier for that single chunk. Then, using those same groups, pipe to a `summarize()` call, where you apply the new threshold estimator function to the data. The resulting output will have 4 columns and 9352 rows.








