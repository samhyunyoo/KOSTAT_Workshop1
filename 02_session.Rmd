---
title: "Session 2 notes"
author: "Tim Riffe"
date: "2023-07-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is just text, we can write as we like here.
Sometime you'll see me put code-like things in side of `back ticks`. That is just for text formatting, it isn't actually code.

To make an R snippet use `Ctrl Alt i`, commit to muscle memory

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
KOR <- read_csv("https://raw.githubusercontent.com/timriffe/KOSTAT_Workshop1/master/Data/KOR2014.csv")
options(scipen = 999)

KOR |> # Ctrl Shift m makes either |> or %>% (both are pipes)
  mutate(mx = deaths / exposure) |> 
  filter(sex != "total") |> 
  ggplot(mapping = aes(x = age, y = mx, color = sex)) +
  geom_line(linewidth = 3) +
  geom_hline(yintercept = 0.00289,color = "#8a36ba") +
  scale_y_log10() +
  theme_minimal() +
  theme(axis.text = element_text(size = 16),
        axis.title = element_text(size = 16))
```

## the lifetable functions

Recall the first step of calculating a period lifetable is to convert rates to probabilities. Here's the trick we use:

$$
{}_nq_x = \frac{n \cdot {}_nM_x}{1 + (n - {}_nA_x) \cdot {}_nM_x} \\
q_x = f(m_x,a_x,n_x)

$$


$q_x$ is the notation for a conditional death probability.
$a_x$ is the average time spend in the age interval of those that don't survive until the end of the age interval. Usually we just say that this is half of the interval width.
```{r}
mx <-
  KOR |> 
  mutate(mx = deaths / exposure) |> 
  filter(sex == "total") |> 
  pull(mx)

ax    <- rep(.5, 111)
ax[1] <- .1
n     <- rep(1,111)
qx    <- (n * mx) / (1 + (n - ax) * mx)
```


## functions

The anatomy of a function

`name`, which we assign the metafunction `function()` to, where we list the arguments (parameters) of our function inside its parentheses. The function body starts and stops with `{}`. What you do with the arguments inside of the `{}` is your own business. The only thing that gets out of the function is what you put inside `return()`, at the end of the function body.


```{r}
calc_qx <- function(mx, ax, n){ # function body starts here
  qx    <- (n * mx) / (1 + (n - ax) * mx)
  return(qx)
} # ends here

# calc_qx(mx, ax, n)
```

## survival curve

$$
\ell_x = \prod _{i=0}^{x-1} (1 - q_i)
$$

The core piece of the function is the operation of `cumsum(1-qx)`.
We stick a 1 on the front to get a clean start to the cohort. 
Then we make sure the vector is the same length as what we started with (`qx`)
Then we optionally rescale the whole `lx` vector to an arbitrary radix size. The most common choice is 100000, but mathematical demographers prefer the value of 1 when doing work.

```{r}
calc_lx <- function(qx, radix = 1){

  lx <- cumprod(1 - qx)
  lx <- c(1, lx)
  lx <- lx[1:111]
  lx <- radix * lx
  return(lx)
}
lx <- calc_lx(qx, radix = 100000)

```

## derive the death distribution from lx

$$ d_x = \ell_{x+1} - \ell_x$$
$$ d_x = \ell_x \cdot q_x$$
This is the preferred way to code the death distribution calculation because all the elements are already the right length and aligned. We ensure that the resulting `dx` adds up to the `radix` value by setting the final value of `qx` to 1. If we didn't do that, it would mean that not everyone dies. It's sort of a detail, but we do it for rigor.

```{r}
calc_dx <- function(lx,qx){
  qx[111] <- 1
  
  dx <- lx * qx
  return(dx)
}

calc_dx(lx,qx) |> sum()
```

```{r}
calc_dx2 <- function(lx){
  lx <- c(lx,0)
  dx <- -diff(lx)
  return(dx)
}
dx <- calc_dx(lx,qx)
```

## First estimate of $e(0)$

Exercise: implement an estimate of $e_0$ given $d_x$, using it to weight together ages.

```{r}
age <- seq(0,110,by=1)
# this was a check to see how much leverage the
# first and last ax values have 
# ax[1]   <- .14
# ax[111] <- 1.41
sum((age+ax) * dx) / sum(dx)
```

```{r}
sum(lx / 1e5) - 0.5
```

## Get a decent estimate of `L_x`

$$ L_x = l_{x+n} + a_x \cdot d_x$$
$$ L_x = n \cdot l_x - (n - a_x) \cdot d_x$$

```{r}
calc_Lx <- function(qx,ax,n, radix = 1){
  lx <- calc_lx(qx, radix = radix)
  dx <- calc_dx(lx,qx)
  
  Lx <- lx * n - (n - ax) * dx
  return(Lx)
}
# from Neha:
calc_Lx <- function(lx,dx,ax,n){
  Lx <- lx * n - (n - ax) * dx
  return(Lx)
}
Lx <- calc_Lx(lx,dx,ax,n)
sum(Lx / 1e5)
sum(lx)/1e5 - .5
```

## `Tx` $T_x$

The total years left to live in the synthetic cohort beyond age $x$, $T_x$

$$ T_x = \sum _{i=x}^\omega L_i$$
```{r}
calc_Tx <- function(Lx){
Tx <- Lx |> 
  rev() |> 
  cumsum() |> 
  rev()
return(Tx)
}
calc_ex <- function(Tx,lx){
  ex <- Tx / lx
  return(ex)
}
```

## using the functions together
```{r}
KOR |> 
  filter(sex == "total") |> 
  mutate(mx = deaths / exposure,
         ax = c(.14,rep(.5,109),1.4),
         n = rep(1,111),
         qx = calc_qx(mx,ax,n),
         lx = calc_lx(qx),
         dx = calc_dx(lx,qx),
         Lx = calc_Lx(lx,dx,ax,n),
         Tx = calc_Tx(Lx),
         ex = calc_ex(Tx,lx))
```


## loading in self-written functions

I copied all of our functions into an R script (a file ending in `.R`) called `lifetable_utils.R`. We can load these into our R session straight from the web like so:

This little piece of code is in the Google Doc.
```{r}
source("https://raw.githubusercontent.com/timriffe/KOSTAT_Workshop1/master/lifetable_utils.R")
```

If you run that line of code, it gives you all the functions I just wrote. 

## make the lifetable for all subsets

```{r}
LT <- 
KOR |> 
  group_by(sex) |> 
  mutate(mx = deaths / exposure,
         ax = c(.14,rep(.5,109),1.4),
         n = rep(1,111),
         qx = calc_qx(mx,ax,n),
         lx = calc_lx(qx),
         dx = calc_dx(lx,qx),
         Lx = calc_Lx(lx,dx,ax,n),
         Tx = calc_Tx(Lx),
         ex = calc_ex(Tx,lx)) 
LT |> 
  ggplot(mapping = aes(x = age,
                       y = ex,
                       color = sex)) +
  geom_line() +
  geom_abline(intercept = 80, slope = -1)
```

## Fertility

```{r}
B <-
  KOR |> 
  filter(births > 0) |> 
  select(age, births)

fert <-
  KOR |> 
  filter(sex == "female") |> 
  select(age, exposure) |> 
  right_join(B, by = "age")

fert |> 
  mutate(fx = births / exposure) |> 
  ggplot(mapping = aes(x = age,
                       y = fx)) +
  geom_line()
```

## Mean age at childbearing

`summarize()` is for aggregation. We can create various new columns in succession using comma separated statements. In this case, we can use this data to calculate TFR (sum of ASFR), and the mean age at childbearing. For this we compared MAB using births as weights and using rates as weights. I think it's better to use rates as weights when making comparisons or trends. We add 1/2 to age to weight using the midpoints, since births are scattered over the year.

```{r}
fert |> 
  mutate(fx = births / exposure,
         age2 = age + .5) |> 
  summarize(TFR = sum(fx),
            MAB_fx = sum(fx * age2) / sum(fx),
            MAB_B = sum(births * age2) / sum(births))
```


## Exercise, calculate NRR

The NRR, or net reproductive ratio, tries to approximate the average number of daughters per woman for a cohort of women subject to mortality. Don't take it too seriously. It's also denoted using $R(0)$ sometimes. This is the same statistic commonly reported in conservation biology or viral epidemiology. The number .4886 is a Berkeley demography tradition. So the story, Ken Wachter always uses this number as a stand-in for 1/SRB due to a once-upon-a-time calculation for a population long forgotten. You can of course use a different approximation of the proportion of births that are female.

$$
NRR = \sum_{12}^{55} L_x^{female} \cdot f_x \cdot .4886
$$

 0.583 came from Dol Narayan, spot on if we us .4886.
 
 To calculate this we need to first set up the data. We start with the lifetables we already made. To do that I modified the earlier code chunk where we made the lifetables. Rather than visualizing them (and then losing that info) I saves them to an object `LT`, that way we can use them later (here). Then I filter down to females and join `B` to this, then plug in 0s for the NAs (no fert data outside of ages 12-55), then we calculate the measure in `summarize()` since this is a form of aggregation. In the end we got the empirical proportion female of births from the HMD births file.

```{r}

PFB <- 1 / (1 + 223356/212079)
LT |> 
  ungroup() |> 
  filter(sex == "female") |> 
  select(-births) |> 
  left_join(B, by = "age") |> 
  mutate(births = if_else(is.na(births), 0, births),
         fx = births / exposure) |> 
  select(age, Lx, fx) |> 
  summarize(NRR = PFB * sum(Lx * fx))
  
```




















