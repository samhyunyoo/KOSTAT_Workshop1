---
title: "Session 2 notes"
author: "Tim Riffe"
date: "2022-07-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## tidy data defintion

A dataset is *tidy* if each row is an observation and each column is a variable, which could be structural (or key) variables that identify a unique observation, or rather variables that characterize the observation.

## Example tidy dataset: `gapminder`

If you want to see the innagural presentation of this dataset, go to youtube and type "Hans Rosling".

`Ctrl + Alt + i` for the code chunk, `Ctrl + Enter` to execute a line.
```{r, message = FALSE}
# install.packages("gapminder")
library(gapminder)
gapminder
str(gapminder)
summary(gapminder)

dim(gapminder)
ncol(gapminder)
```

## more specific queries

`Ctrl + Shift + m`
```{r, message = FALSE}
library(tidyverse)
gapminder %>% 
  pull(year) %>% 
  range()
```

Mini exercise: list the unique countries in the dataset using the sort of syntax we just wrote. 3 min.

```{r, results = "hide"}
gapminder %>% 
  pull(country) %>% 
  unique()
```

## A bit more explicit about pipes

A pipe `%>%` (`Ctrl + Shift + m`) separates the steps of a sequence of data processing operations. It glues them together. It takes the result of the cumulative sequence of operations on the left, and feeds it directly to the operation on the right.

Below we have two versions of an identical operation. The first saves the intermediate results. The second flies through them and produces only the final result, which is identical because we used the same random numbers (see note below). I argued that this is nice because it makes the code more fluid and easier to translate into human language. It also keeps the garden (workspace) clean and free of one-time-use objects.
```{r}
set.seed(1)
c(1,2,3)
a <- runif(10)
b <- sort(a)
d <- cumsum(b)
e <- exp(d)
e

set.seed(1)
e <-
  runif(10) %>% 
  sort() %>% 
  cumsum() %>% 
  exp()
```
We used `set.seed()` to determine the position in the (infinite) sequence of random draws. Imagine a pseudo-random number table in the back of an old stats textbook. `set.seed()` says, go the nth position and start there.

## `filter()` is for rows

row-filtering is done by producing a logical vector inside of `filter()`. We keep the rows that evaluate to `TRUE` and toss the rows that evaluate to `FALSE`.
```{r}
gapminder %>% 
  filter(country == "Korea, Rep.")

# Ctrl Shift c to comment out this bit:
# gapminder %>% 
#   pull(country) %>% 
#   '=='("Korea, Rep.")
```

### Time out for logicals

```{r}
A <- tibble(a = 1:10,
            b = letters[1:10])

# greater than or equal to
A %>% 
  filter(a >= 5)

# >, <, >=, <=

# negation is with !
A %>% 
  filter(b != "c")

# %in% is for set membership
A %>% 
  filter(b %in% c("a","f","g"))

# multiple criteria
A %>% 
  filter(a > 3,
         b %in% c("a","e","h","i"))

## | is a logical OR operator
A %>% 
  filter(a > 3 | b %in% c("a","e","h","i"))

# same thing, less verbose:
x <- c("a","e","h","i")
A %>% 
  filter(a > 3 | b %in% x)

#
A %>% 
  filter(a > 4,
         a <= 8)

A %>% 
  filter(between(a, 4, 8))
?between
```

Mini exercise:

Tell me which country-year has the highest and which has the lowest life expectancy in `gapminder`.

```{r}
gapminder %>% 
  filter(lifeExp == min(lifeExp) |
           lifeExp == max(lifeExp))

gapminder %>% 
  filter(lifeExp %in% c(min(lifeExp), max(lifeExp)))

gapminder %>% 
  filter(lifeExp %in% range(lifeExp))

```






